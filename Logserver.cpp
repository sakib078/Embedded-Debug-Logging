#include <iostream>#include <fstream>#include <cstring>#include <sys/socket.h>#include <netinet/in.h>#include <arpa/inet.h>#include <unistd.h>#include <thread>#include <mutex>#include "Logger.h"#define BUF_LEN 1024#define SERVER_PORT 12005/* sakib sirajbhai mansuri  id : 122728223 */// Global variablesstatic int sockfd;static sockaddr_in serverAddr, clientAddr;static std::mutex logMutex;static bool isRunning = true;void ReceiveThread() {    std::ofstream logFile("server_log.txt", std::ios::app); // Open file in append mode    if (!logFile.is_open()) {        std::cerr << "Error opening log file for writing" << std::endl;        return; // Exit the function if unable to open the file    }    char buf[BUF_LEN];    socklen_t addrLen = sizeof(clientAddr);    while (isRunning) {        // Non-blocking receive        int len = recvfrom(sockfd, buf, BUF_LEN, MSG_DONTWAIT, (struct sockaddr *)&clientAddr, &addrLen);        if (len > 0) {           // std::cout << buf << std::endl;            if (logFile.is_open()) {                logFile << buf << std::endl; // Write log message to file                logFile.flush(); // Flush the output buffer to ensure immediate writing to the file            } else {                std::cerr << "Error writing to log file (file not open)" << std::endl;            }        }        std::this_thread::sleep_for(std::chrono::seconds(1)); // Sleep for 1 second if nothing is received    }        logFile.close(); // Close the log file when the thread exits}// Function to dump log file contentsvoid DumpLogFile() {    while (isRunning) {        std::ifstream logfile("server_log.txt");        if (!logfile.is_open()) {            std::cerr << "Error opening log file" << std::endl;            break;        }        std::cout << "----------Server Log File Contents------------" << std::endl;        std::string line;        while (std::getline(logfile, line)) {            std::cout << line << std::endl;        }        logfile.close();        std::cout << "--------------------------" << std::endl;        std::cout << "Press any key to continue: ";        break;        std::cin.ignore(); // Ignore previous newline character        std::cin.get();    // Wait for user input        sleep(1);    }}// Function to display user menuvoid UserMenu() {    char choice;    do {        std::cout << "User Menu:" << std::endl;        std::cout << "1. filter log level" << std::endl;        std::cout << "2. Dump the log file" << std::endl;        std::cout << "0. Shut down" << std::endl;        std::cout << "Enter your choice: ";        std::cin >> choice;        switch (choice) {            case '1': {                int level;                std::cout << "Enter the filter log severity: " << std::endl;                std::cout << "DEBUG   = 0"<< std::endl;                std::cout << "WARNING = 1"<< std::endl;                std::cout << "ERROR   = 2"<< std::endl;                std::cout << "CRITICAL= 3"<< std::endl;                                std::cin >> level;                char buf[BUF_LEN];                memset(buf, 0, BUF_LEN);                int len = sprintf(buf, "Set Log Level=%d", level) + 1;                std::lock_guard<std::mutex> lock(logMutex);                sendto(sockfd, buf, len, 0, (struct sockaddr *)&clientAddr, sizeof(clientAddr));                break;            }            case '2': {                // Dump the log file                DumpLogFile();                break;            }            case '0':                isRunning = false;                break;            default:                std::cout << "Invalid choice. Please try again." << std::endl;        }    } while (choice != '0');}int main() {    // Create UDP socket    sockfd = socket(AF_INET, SOCK_DGRAM, 0);    if (sockfd < 0) {        perror("Error creating socket");        return -1;    }    // Configure server address    serverAddr.sin_family = AF_INET;    serverAddr.sin_addr.s_addr = INADDR_ANY;    serverAddr.sin_port = htons(12005);    // Bind socket    if (bind(sockfd, (struct sockaddr *)&serverAddr, sizeof(serverAddr)) < 0) {        perror("Error binding socket");        return -1;    }    // Start receive thread    std::thread recvThread(ReceiveThread);    recvThread.detach(); // Detach the thread            // User    UserMenu();        close(sockfd);        return 0;}            